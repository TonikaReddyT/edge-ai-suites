From a598ca8d78f4218c260edeabd2ba349ddf399330 Mon Sep 17 00:00:00 2001
From: tao-ov <tao.xiong@intel.com>
Date: Wed, 18 Jun 2025 11:27:28 -0400
Subject: [PATCH 1/3] Replace diffusion_pointcloud_policy.py with cleaned
 version

---
 .../policy/diffusion_pointcloud_policy.py     | 25 +++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/Improved-3D-Diffusion-Policy/diffusion_policy_3d/policy/diffusion_pointcloud_policy.py b/Improved-3D-Diffusion-Policy/diffusion_policy_3d/policy/diffusion_pointcloud_policy.py
index e2b405c..1469517 100644
--- a/Improved-3D-Diffusion-Policy/diffusion_policy_3d/policy/diffusion_pointcloud_policy.py
+++ b/Improved-3D-Diffusion-Policy/diffusion_policy_3d/policy/diffusion_pointcloud_policy.py
@@ -55,6 +55,7 @@ class DiffusionPointcloudPolicy(BasePolicy):
             raise NotImplementedError(f"Unsupported action shape {action_shape}")
             
         obs_shape_meta = shape_meta['obs']
+        print("[!!!]", obs_shape_meta)
         obs_dict = dict_apply(obs_shape_meta, lambda x: x['shape'])
 
         obs_encoder = iDP3Encoder(observation_space=obs_dict,
@@ -63,7 +64,7 @@ class DiffusionPointcloudPolicy(BasePolicy):
                                                 pointnet_type=pointnet_type,
                                                 point_downsample=point_downsample,
                                                 )
-
+        print("[!!!]", obs_encoder)
         # create diffusion model
         obs_feature_dim = obs_encoder.output_shape()
         input_dim = action_dim + obs_feature_dim
@@ -219,6 +220,13 @@ class DiffusionPointcloudPolicy(BasePolicy):
                                 timestep=t, 
                                 local_cond=local_cond, global_cond=global_cond)
             
+            if t==0:
+                cprint(f"[DiffusionPointcloudPolicy] sample: {trajectory.shape}", "cyan")
+                cprint(f"[DiffusionPointcloudPolicy] condition_data: {condition_data.shape}", "cyan")
+                cprint(f"[DiffusionPointcloudPolicy] condition_mask: {condition_mask.shape}", "cyan")
+                cprint(f"[DiffusionPointcloudPolicy] timesteps: {t}", "cyan")
+                cprint(f"[DiffusionPointcloudPolicy] local_cond: {local_cond.shape if isinstance(local_cond, torch.Tensor) else local_cond}", "cyan")
+                cprint(f"[DiffusionPointcloudPolicy] global_cond: {global_cond.shape if isinstance(global_cond, torch.Tensor) else global_cond}", "cyan")
             # 3. compute previous image: x_t -> x_t-1
             trajectory = scheduler.step(
                 model_output, t, trajectory, ).prev_sample
@@ -227,9 +235,22 @@ class DiffusionPointcloudPolicy(BasePolicy):
         # finally make sure conditioning is enforced
         trajectory[condition_mask] = condition_data[condition_mask]   
 
-
         return trajectory
 
+    # def diffusion_unet_forward(self, trajectory, t, global_cond, local_cond,condition_data, condition_mask):
+    #     # run sampling
+    #     trajectory[condition_mask] = condition_data[condition_mask]
+    #     model_output = self.model(trajectory, t, global_cond = global_cond, local_cond=local_cond)
+    #     return model_output
+
+    def diffusion_unet_forward(self, trajectory, t, global_cond, local_cond):
+        # run sampling
+        #trajectory[condition_mask] = condition_data[condition_mask]
+        model_output = self.model(trajectory, t, global_cond = global_cond, local_cond=local_cond)
+        return model_output
+
+    
+        
     def predict_action(self, obs_dict: Dict[str, torch.Tensor]) -> Dict[str, torch.Tensor]:
         """
         obs_dict: must include "obs" key
-- 
2.34.1

