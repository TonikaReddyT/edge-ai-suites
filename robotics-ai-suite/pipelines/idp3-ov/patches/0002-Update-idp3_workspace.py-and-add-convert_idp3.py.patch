From bdd5cdb9a692c2894bea7e015132a480d986bf5c Mon Sep 17 00:00:00 2001
From: tao-ov <tao.xiong@intel.com>
Date: Wed, 18 Jun 2025 12:37:56 -0400
Subject: [PATCH 2/3] Update idp3_workspace.py and add convert_idp3.py

---
 Improved-3D-Diffusion-Policy/convert_idp3.py  | 119 ++++++++++++++++++
 .../workspace/idp3_workspace.py               |   2 +-
 2 files changed, 120 insertions(+), 1 deletion(-)
 create mode 100755 Improved-3D-Diffusion-Policy/convert_idp3.py

diff --git a/Improved-3D-Diffusion-Policy/convert_idp3.py b/Improved-3D-Diffusion-Policy/convert_idp3.py
new file mode 100755
index 0000000..da8f661
--- /dev/null
+++ b/Improved-3D-Diffusion-Policy/convert_idp3.py
@@ -0,0 +1,119 @@
+"""
+Use DiffusionPolicy as model
+use its predict_action function as forward / inference
+
+"""
+import hydra
+import torch
+import dill
+import os
+
+ckpt = "latest.ckpt"
+
+ckpt_name = ckpt.split("/")[-1].split(".ckpt")[0]
+output_dir = "onnx_ckpt" # save onnx convert result
+# create folder
+os.makedirs(output_dir, exist_ok=True)
+# load checkpoint
+payload = torch.load(open(ckpt, 'rb'), pickle_module=dill)
+# read config from checkpoint
+cfg = payload['cfg']
+# for k, v in cfg.items():
+#     print("{}: {}".format(k, v))
+# hack target
+cfg._target_ = "diffusion_policy_3d.workspace.idp3_workspace.iDP3Workspace"
+cls = hydra.utils.get_class(cfg._target_)
+print("[!!!]", cfg.policy.shape_meta)
+# create model
+workspace = cls(cfg, output_dir=output_dir)
+
+print(f"cls: {cls}, workspace: {workspace}")
+# load pre-trained weights
+workspace.load_checkpoint(ckpt)
+# workspace.load_payload(payload, exclude_keys=None, include_keys=None)
+# model
+policy = workspace.model # diffusion policy, not torch nn.Module
+
+class ConvertModel(torch.nn.Module):
+    def __init__(self, policy):
+        super(ConvertModel, self).__init__()
+        self.policy = policy
+        self.policy.model.eval()  # Ensure the model is in evaluation mode
+        self.policy.obs_encoder.eval()
+        #self.cnn_model = cnn_model
+
+        # Wrapping obs encoder
+        class ConvertObsEncoder(torch.nn.Module):
+            def __init__(self, policy):
+                super(ConvertObsEncoder, self).__init__()
+                self.policy = policy
+            
+            def forward(self, agent_pos, point_cloud):
+                with torch.no_grad():
+                    obs_dict = {"agent_pos": agent_pos, "point_cloud": point_cloud}
+                    return self.policy.obs_encoder.forward(obs_dict)
+        
+        # Wrapping diffusion model
+        class ConvertUnetModel(torch.nn.Module):
+            def __init__(self, policy, cnn_model=False):
+                super(ConvertUnetModel, self).__init__()
+                self.policy = policy
+                self.forward = self.forward_cnn
+
+            
+            def forward_cnn(self, trajectory, t, global_cond, local_cond):
+                print("==> trajectory: ", trajectory.shape)
+                print("==> t: ", t.shape)
+                print("==> local_cond: ", local_cond.shape if local_cond is not None else local_cond)
+                print("==> global_cond: ", global_cond.shape if global_cond is not None else global_cond)
+                # print("==> cond_data: (data processing)", cond_data.shape)
+                # print("==> cond_mask: (data processing)", cond_mask.shape)
+                with torch.no_grad():
+                    return self.policy.diffusion_unet_forward(trajectory, t, global_cond, local_cond)
+            
+        self.convert_obs_encoder = ConvertObsEncoder(self.policy)
+        self.convert_diffusion_unet = ConvertUnetModel(self.policy)
+    
+    @torch.no_grad()
+    def export_onnx(self, output_dir, ckpt_name):
+        # Export obs_encoder
+        agent_pos = torch.rand(1, 32)
+        point_cloud = torch.rand(1, 4096, 3)
+        local_cond = None
+        # global_cond = self.convert_obs_encoder(agent_pos, point_cloud)
+
+        export_name_obs_encoder = os.path.join(output_dir, f"{ckpt_name}_obs_encoder.onnx")
+        torch.onnx.export(
+            self.convert_obs_encoder,
+            (agent_pos, point_cloud),
+            export_name_obs_encoder,
+            export_params=True,
+            opset_version=13,
+            do_constant_folding=True,
+        )
+        print(f"[===] Obs Encoder exported to {export_name_obs_encoder}")
+
+        # Export diffusion unet
+        #trajectory = torch.randn_like(cond_data)
+        trajectory = torch.randn(1, 16, 25)
+        # t = torch.tensor([10], dtype=torch.float32)
+        t = torch.randint(100, size=(1,)).float()
+        # condition_data = torch.randn(29, 16, 25)
+        # condition_mask = (torch.randn(29, 16, 25) < 0.5).bool()
+        global_cond = torch.randn(1,384)
+        export_name_unet = os.path.join(output_dir, f"{ckpt_name}_unet.onnx")
+        #unet_inputs = (trajectory, t,global_cond,local_cond,condition_data, condition_mask)
+        unet_inputs = (trajectory, t,global_cond,local_cond)
+        torch.onnx.export(
+            self.convert_diffusion_unet,
+            unet_inputs,
+            export_name_unet,
+            export_params=True,
+            opset_version=13,
+            do_constant_folding=True,
+        )
+        print(f"[===] Diffusion UNet exported to {export_name_unet}")
+
+convert_model = ConvertModel(policy)
+# convert to onnx
+convert_model.export_onnx(output_dir, ckpt_name)
\ No newline at end of file
diff --git a/Improved-3D-Diffusion-Policy/diffusion_policy_3d/workspace/idp3_workspace.py b/Improved-3D-Diffusion-Policy/diffusion_policy_3d/workspace/idp3_workspace.py
index be1b9b5..dd93508 100644
--- a/Improved-3D-Diffusion-Policy/diffusion_policy_3d/workspace/idp3_workspace.py
+++ b/Improved-3D-Diffusion-Policy/diffusion_policy_3d/workspace/idp3_workspace.py
@@ -46,6 +46,7 @@ class iDP3Workspace(BaseWorkspace):
 
         # configure model
         self.model: DiffusionPointcloudPolicy = hydra.utils.instantiate(cfg.policy)
+        print("==>", self.model.__class__)
 
         self.ema_model: DiffusionPointcloudPolicy = None
         if cfg.training.use_ema:
@@ -82,7 +83,6 @@ class iDP3Workspace(BaseWorkspace):
             RUN_CKPT = True
             verbose = False
         
-        
         # resume training
         if cfg.training.resume:
             lastest_ckpt_path = self.get_checkpoint_path()
-- 
2.34.1

